<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibraLight Cosmic Genesis</title>
    
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 3. Load 3D Controls & Post-Processing Effects -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <style>
        /* 4. Set Inter font and dark mode */
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling */
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        /* Custom scrollbar for control panel */
        ::-webkit-scrollbar {
            width: 5px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #718096; /* gray-500 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* gray-400 */
        }
        /* NEW: Style for the A-LMI Knowledge Graph bars */
        .freq-bar {
            transition: width 0.3s ease-out;
        }
    </style>
    <!-- 5. Preload Inter font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
</head>
<body>
    <!-- 6. Canvas for the 3D simulation -->
    <canvas id="simulationCanvas"></canvas>

    <!-- 7. Control Panel Overlay (Upgraded) -->
    <div id="menuPanel" class="absolute top-4 left-4 bg-gray-900 bg-opacity-80 backdrop-blur-md p-6 rounded-lg shadow-lg max-w-sm max-h-[95vh] overflow-y-auto transition-all duration-300">
        <!-- Header with Toggle Button -->
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold text-white">VibraLight Genesis</h1>
            <button id="menuToggleButton" class="text-gray-400 hover:text-white transition-colors">
                <!-- Minimize Icon -->
                <svg id="minimizeIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path></svg>
                <!-- Maximize Icon (hidden by default) -->
                <svg id="maximizeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4h4m12 0h-4v4m0 8v4h-4m-8 0H8v-4"></path></svg>
            </button>
        </div>

        <!-- Content wrapper for toggling -->
        <div id="menuContent">
            <p class="text-sm text-gray-300 mb-6">
                A universe built on your documents. Your voice <strong>creates</strong> form.
                Pitch (frequency) determines particle color &amp; harmonic structure ($\Phi$).
                Volume (amplitude) determines mass (particle count) &amp; birth energy ($Ec$). This is <strong>Cymatics</strong>.
            </p>

            <!-- Mic Button -->
            <button id="toggleMicButton" class="w-full bg-cyan-500 hover:bg-cyan-400 text-black font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-md mb-4">
                Toggle VibraLight (Mic)
            </button>
            <div id="micStatus" class="text-center text-gray-400 text-xs mb-6">Mic OFF. Using Baseline Chaos.</div>

            <!-- Particle Controls -->
            <div class="grid grid-cols-2 gap-4 mb-2">
                <button id="addParticlesButton" class="bg-blue-600 hover:bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                    Add 10k 'Soul Dust'
                </button>
                <button id="clearParticlesButton" class="bg-red-700 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                    Clear 'Soul Dust'
                </button>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <button id="addAttractorButton" class="bg-purple-600 hover:bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                    Add Black Hole
                </button>
                <button id="clearAllButton" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-all">
                    Clear Universe
                </button>
            </div>


            <!-- Simulation Parameters -->
            <div class="space-y-4">
                <!-- Swirl (Omega) -->
                <div>
                    <label for="swirlSlider" class="block text-sm font-medium text-gray-200">Swirl ($\Omega$)</label>
                    <input id="swirlSlider" type="range" min="0" max="1" step="0.01" value="0.3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="swirlValue" class="text-xs text-gray-400">0.3</span>
                </div>
                <!-- Gravity (G) -->
                <div>
                    <label for="gravitySlider" class="block text-sm font-medium text-gray-200">Gravity ($G$)</label>
                    <input id="gravitySlider" type="range" min="0" max="10000" step="100" value="3000" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="gravityValue" class="text-xs text-gray-400">3000</span>
                </div>
                <!-- Damping (zeta) -->
                <div>
                    <label for="dampingSlider" class="block text-sm font-medium text-gray-200">Damping ($\zeta$)</label>
                    <input id="dampingSlider" type="range" min="0.001" max="0.1" step="0.001" value="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="dampingValue" class="text-xs text-gray-400">0.02</span>
                </div>
                <!-- Baseline Chaos (lambda) -->
                <div>
                    <label for="lambdaSlider" class="block text-sm font-medium text-gray-200">Baseline Chaos ($\lambda$)</label>
                    <input id="lambdaSlider" type="range" min="0" max="20" step="0.1" value="3.0" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    <span id="lambdaValue" class="text-xs text-gray-400">3.0</span>
                </div>
            </div>

            <!-- Debug Info -->
            <div class="mt-6 border-t border-gray-700 pt-4">
                <h3 class="text-lg font-semibold text-white mb-2">Live Data</h3>
                <div class="text-sm text-gray-300">
                    <div>Attractors: <span id="attractorCount">0</span></div>
                    <div>'Soul Dust' Particles: <span id="particleCount">0</span></div>
                    <div>Avg. PSD (norm): <span id="psdValue">0.00</span></div>
                    <div>Final Chaos ($\sigma$): <span id="sigmaValue">0.00</span></div>
                </div>
            </div>

            <!-- A-LMI Memory Matrix (Temporal Knowledge Graph) -->
            <div id="almiMemoryMatrix" class="mt-6 border-t border-gray-700 pt-4">
                <h3 class="text-lg font-semibold text-white mb-2">A-LMI Memory Matrix (TKG)</h3>
                <p class="text-xs text-gray-400 mb-3">The "Scientist Within" is observing and processing Light Tokens based on their spectral signature (frequency).</p>
                <div class="space-y-2">
                    <!-- Freq. Band 1 (Blue) -->
                    <div class="flex items-center">
                        <div class="w-4 h-4 rounded-full bg-blue-500 border-2 border-blue-200 mr-2"></div>
                        <div class="flex-1 bg-gray-700 rounded-full h-4">
                            <div id="freqBar_0" class="freq-bar h-4 rounded-full bg-blue-500" style="width: 0%"></div>
                        </div>
                        <span id="freqCount_0" class="ml-2 text-xs text-gray-300 w-8 text-right">0</span>
                    </div>
                    <!-- Freq. Band 2 (Cyan) -->
                    <div class="flex items-center">
                        <div class="w-4 h-4 rounded-full bg-cyan-500 border-2 border-cyan-200 mr-2"></div>
                        <div class="flex-1 bg-gray-700 rounded-full h-4">
                            <div id="freqBar_1" class="freq-bar h-4 rounded-full bg-cyan-500" style="width: 0%"></div>
                        </div>
                        <span id="freqCount_1" class="ml-2 text-xs text-gray-300 w-8 text-right">0</span>
                    </div>
                    <!-- Freq. Band 3 (Purple) -->
                    <div class="flex items-center">
                        <div class="w-4 h-4 rounded-full bg-purple-500 border-2 border-purple-200 mr-2"></div>
                        <div class="flex-1 bg-gray-700 rounded-full h-4">
                            <div id="freqBar_2" class="freq-bar h-4 rounded-full bg-purple-500" style="width: 0%"></div>
                        </div>
                        <span id="freqCount_2" class="ml-2 text-xs text-gray-300 w-8 text-right">0</span>
                    </div>
                    <!-- Freq. Band 4 (Magenta) -->
                    <div class="flex items-center">
                        <div class="w-4 h-4 rounded-full bg-fuchsia-500 border-2 border-fuchsia-200 mr-2"></div>
                        <div class="flex-1 bg-gray-700 rounded-full h-4">
                            <div id="freqBar_3" class="freq-bar h-4 rounded-full bg-fuchsia-500" style="width: 0%"></div>
                        </div>
                        <span id="freqCount_3" class="ml-2 text-xs text-gray-300 w-8 text-right">0</span>
                    </div>
                </div>
                <div class="text-right text-sm text-gray-300 mt-3">Total Tokens: <span id="totalTokenCount" class="font-bold">0</span></div>
            </div>
        </div> <!-- End menuContent -->
    </div>
    
    <!-- 8. JavaScript Logic (Upgraded with A-LMI) -->
    
    <!-- 8a. GLSL Shader Code for 'Soul Dust' Particles -->
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute float speed;
        attribute float internalState; // Particle's imprinted frequency (Omega)
        
        varying float vSpeed;
        varying float vInternalState; 

        void main() {
            vSpeed = speed;
            vInternalState = internalState;
            
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            
            // Cosmic Shimmer - size oscillates based on position
            float shimmer = 0.95 + 0.05 * sin(position.x + position.y);
            gl_PointSize = (250.0 / -mvPosition.z) * shimmer;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying float vSpeed;
        varying float vInternalState; // Received from vertex shader

        void main() {
            // Create a soft, glowing circular point
            float d = distance(gl_PointCoord, vec2(0.5, 0.5));
            if (d > 0.5) discard; // Make it a circle
            
            // Fade out at the edges
            float alpha = 1.0 - d * 2.0;

            // --- Velocity-Driven & InternalState-Driven Color ---
            
            // 1. Base color is from imprinted frequency (vInternalState)
            //    Maps 0.0 -> 1.0 to Blue (0.66 HSL) -> Magenta (0.83 HSL)
            float hue = 0.66 + vInternalState * 0.17;
            vec3 baseColor = vec3(1.0); 
            
            // HSL to RGB conversion (simplified)
            float c = 1.0;
            float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
            float m = 0.0;
            if (hue < 0.166) baseColor = vec3(c, x, 0.0);
            else if (hue < 0.333) baseColor = vec3(x, c, 0.0);
            else if (hue < 0.5) baseColor = vec3(0.0, c, x);
            else if (hue < 0.666) baseColor = vec3(0.0, x, c);
            else if (hue < 0.833) baseColor = vec3(x, 0.0, c);
            else baseColor = vec3(c, 0.0, x);
            baseColor += m;
            
            // 2. "Hot" color for high velocity (star exploding)
            float intensity = smoothstep(10.0, 40.0, vSpeed); 
            vec3 hotColor = vec3(1.0, 1.0, 0.9); // Bright white-hot

            // 3. Final color mixes base (imprinted) color with velocity (hot) glow
            vec3 finalColor = mix(baseColor, hotColor, intensity);

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>
    
    <!-- 8b. Main Simulation Script -->
    <script type="module">
        // === Setup: Canvas, 3D Scene, and State ===
        const canvas = document.getElementById('simulationCanvas');
        let width = window.innerWidth;
        let height = window.innerHeight;

        let scene, camera, renderer, controls, clock;
        let composer, bloomPass;
        let points;
        let attractors = [];
        let attractorMeshes;
        let particleCount = 0;

        // Particle data buffers
        let positions, velocities, speeds;
        let internalStates; // "Quantum Brain" / Imprinted Frequency (Omega)
        let internalAmplitudes; // Imprinted Energy (Ec)

        // Audio State
        let audioContext = null;
        let analyser = null;
        let micOn = false;
        let psdNormalized = 0.0;
        const micColor = new THREE.Color(); 
        let fftDataArray; // To find dominant frequency
        
        // --- A-LMI State ---
        let almiCore; // The "Scientist Within" mesh
        let almiScanTimer = 0;
        const ALMI_SCAN_INTERVAL = 3.0; // Seconds
        const ALMI_SCAN_RADIUS = 300.0;
        let almiMemory = [0, 0, 0, 0]; // 4 frequency bands
        let almiTotalTokens = 0;
        let lightTokenBeams; // Group for visualization
        const almiCorePos = new THREE.Vector3(0, 0, 0);

        // === Physics Parameters (from CST v2) ===
        const PHI = 1.61803398875; 
        const GOLDEN_ANGLE = Math.PI * (3.0 - Math.sqrt(5.0));
        const K_HARMONIC = 0.01; 
        const SOFTENING = 100; 
        const SIGMA_LAMBDA = 1.0; 
        const SIGMA_PSD = 80.0; 
        const GALAXY_RADIUS = 2000; 
        const PARTICLE_MASS = 1.0;
        const SWIRL_AXIS = new THREE.Vector3(0, 1, 0); 
        const HARMONIC_FLUTTER_STRENGTH = 2.0; 
        const CYMATIC_SPAWN_COUNT = 100; 
        const CYMATIC_RADIUS_MIN = 50; 
        const CYMATIC_RADIUS_MAX = 500; 

        // Slider variables
        let G_CONST = 3000;
        let SWIRL_CONST = 0.3;
        let DAMPING = 0.02;
        let LAMBDA_CONST = 3.0;
        let SIGMA_FINAL = 0; 
        
        // === Physics Helper Vectors ===
        const particlePos = new THREE.Vector3();
        const particleVel = new THREE.Vector3();
        const force = new THREE.Vector3();
        const f_harmonic = new THREE.Vector3();
        const f_grav = new THREE.Vector3();
        const f_swirl = new THREE.Vector3();
        const f_damp = new THREE.Vector3();
        const f_noise = new THREE.Vector3();
        const f_flutter = new THREE.Vector3(); // For the state_i(t) equation
        const accel = new THREE.Vector3();

        // === 3D Scene Initialization ===
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.001); 
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
            camera.position.set(0, 400, 900);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- Post-Processing Bloom ---
            const renderPass = new THREE.RenderPass(scene, camera);
            // NEW: Increased bloom strength and radius
            bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 1.8, 0.2, 0.1); 
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 5000;

            attractorMeshes = new THREE.Group();
            scene.add(attractorMeshes);
            
            lightTokenBeams = new THREE.Group(); 
            scene.add(lightTokenBeams);

            // --- Add the A-LMI Core ---
            const coreGeom = new THREE.IcosahedronGeometry(15, 0);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
            almiCore = new THREE.Mesh(coreGeom, coreMat);
            almiCore.position.copy(almiCorePos);
            scene.add(almiCore);

            addAttractor(new THREE.Vector3(0, 0, 0), 1000, true);
            
            addParticles(10000); 
        }
        
        // === Add Attractor Function ===
        function addAttractor(position, mass, isCentral = false) {
            // The central attractor is now the A-LMI core, skip adding a mesh for it
            if(isCentral) {
                 attractors.push({ pos: position, mass: mass, isCentral: true });
                 return;
            }
            
            attractors.push({ pos: position, mass: mass, isCentral: false });
            
            const geometry = new THREE.SphereGeometry(7, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff, 
                wireframe: true,
                emissive: 0xff00ff,
                emissiveIntensity: 1.0
            });
            const attractorMesh = new THREE.Mesh(geometry, material);
            attractorMesh.position.copy(position);
            
            attractorMeshes.add(attractorMesh);
        }

        // === Particle Setup ===
        function setupParticles() {
            if (points) {
                scene.remove(points);
                points.geometry.dispose();
                points.material.dispose();
            }
            
            if (particleCount === 0) {
                // Ensure buffers are cleared
                positions = new Float32Array(0);
                velocities = new Float32Array(0);
                speeds = new Float32Array(0);
                internalStates = new Float32Array(0);
                internalAmplitudes = new Float32Array(0); 
                return;
            }

            // Create new buffers
            positions = new Float32Array(particleCount * 3);
            velocities = new Float32Array(particleCount * 3);
            speeds = new Float32Array(particleCount);
            internalStates = new Float32Array(particleCount); 
            internalAmplitudes = new Float32Array(particleCount); 

            for (let i = 0; i < particleCount; i++) {
                // Initial position (spherical shell)
                const r = Math.random() * GALAXY_RADIUS * 0.5 + 100;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1); 
                
                positions[i * 3] = Math.sin(phi) * Math.cos(theta) * r;
                positions[i * 3 + 1] = Math.cos(phi) * r;
                positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * r;

                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                speeds[i] = Math.sqrt(velocities[i*3]**2 + velocities[i*3+1]**2 + velocities[i*3+2]**2);
                
                internalStates[i] = Math.random();
                internalAmplitudes[i] = 0.5 + Math.random() * 0.5; // Random base energy
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            geometry.setAttribute('internalState', new THREE.BufferAttribute(internalStates, 1));
            geometry.setAttribute('internalAmplitude', new THREE.BufferAttribute(internalAmplitudes, 1)); 

            const material = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false, 
                vertexColors: false 
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        // === Physics Update ===
        function updatePhysics(dt) {
            if (particleCount === 0) return;

            const posAttr = points.geometry.getAttribute('position');
            const velAttr = points.geometry.getAttribute('velocity');
            const speedAttr = points.geometry.getAttribute('speed');
            const internalStateAttr = points.geometry.getAttribute('internalState');
            const internalAmpAttr = points.geometry.getAttribute('internalAmplitude'); 

            const time = clock.elapsedTime;

            for (let i = 0; i < particleCount; i++) {
                particlePos.fromArray(posAttr.array, i * 3);
                particleVel.fromArray(velAttr.array, i * 3);
                
                // Skip particles being processed by A-LMI
                if (internalStates[i] === -1.0) continue; 
                
                const pOmega = internalStateAttr.getX(i) * 20.0; // Imprinted Frequency (scaled)
                const pEc = internalAmpAttr.getX(i); // Imprinted Energy (Amplitude)
                
                force.set(0, 0, 0);

                // --- Internal Harmonic Oscillation (Vibrational Nature) ---
                // Implementing: state_i(t) = Ec * sin(Omega*t) + lambda * cos(Omega*t)
                const state_i = (pEc * HARMONIC_FLUTTER_STRENGTH * Math.sin(time * pOmega)) + 
                              (SIGMA_FINAL * 0.1 * Math.cos(time * pOmega)); // Chaos term
                
                f_flutter.set(0, state_i, 0); // Apply as a "flutter" on the Y-axis
                force.add(f_flutter);

                // --- Attractor Forces (Gravity, Swirl, Harmonic) ---
                for (const a of attractors) {
                    f_harmonic.subVectors(particlePos, a.pos); 
                    
                    const r_sq = f_harmonic.lengthSq();
                    const r_sq_eps = r_sq + SOFTENING;
                    const r = Math.sqrt(r_sq_eps);
                    const r_cubed = r_sq_eps * r;

                    const f_grav_mag = -(G_CONST * a.mass * PARTICLE_MASS) / r_cubed;
                    f_grav.copy(f_harmonic).multiplyScalar(f_grav_mag);

                    f_harmonic.multiplyScalar(-K_HARMONIC);
                    
                    f_swirl.crossVectors(f_harmonic, SWIRL_AXIS).multiplyScalar(SWIRL_CONST * (a.mass / 1000)); 

                    force.add(f_harmonic).add(f_grav).add(f_swirl);
                }

                // --- System Forces (Damping, Noise) ---
                f_damp.copy(particleVel).multiplyScalar(-DAMPING);
                force.add(f_damp);

                f_noise.set(
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5)
                ).multiplyScalar(SIGMA_FINAL * 0.5); // Global chaos (half strength, flutter is main)
                force.add(f_noise);

                // --- Apply Forces (Integration) ---
                accel.copy(force).divideScalar(PARTICLE_MASS);
                particleVel.add(accel.multiplyScalar(dt));
                particlePos.add(particleVel.multiplyScalar(dt));
                
                const currentSpeed = particleVel.length();
                speedAttr.setX(i, currentSpeed);

                // --- Golden Angle Recycling (Genesis 1:11 Recursion) ---
                if (particlePos.lengthSq() > GALAXY_RADIUS * GALAXY_RADIUS) {
                   const y = 1 - (i / (particleCount - 1)) * 2;
                   const radius = Math.sqrt(1 - y * y);
                   const theta = GOLDEN_ANGLE * i;
                   const spawnRadius = 20.0;
                   
                   particlePos.set(
                       Math.cos(theta) * radius * spawnRadius,
                       y * spawnRadius,
                       Math.sin(theta) * radius * spawnRadius
                   );
                   
                   particleVel.set(
                       (Math.random() - 0.5) * 0.1,
                       (Math.random() - 0.5) * 0.1,
                       (Math.random() - 0.5) * 0.1
                   );
                   speedAttr.setX(i, 0.1);
                }

                posAttr.setXYZ(i, particlePos.x, particlePos.y, particlePos.z);
                velAttr.setXYZ(i, particleVel.x, particleVel.y, particleVel.z);
            }
            
            posAttr.needsUpdate = true;
            velAttr.needsUpdate = true;
            speedAttr.needsUpdate = true;
        }

        // === Control Panel and UI ===
        const toggleMicButton = document.getElementById('toggleMicButton');
        const micStatus = document.getElementById('micStatus');
        const addParticlesButton = document.getElementById('addParticlesButton');
        const clearParticlesButton = document.getElementById('clearParticlesButton');
        const addAttractorButton = document.getElementById('addAttractorButton');
        const clearAllButton = document.getElementById('clearAllButton');
        
        const swirlSlider = document.getElementById('swirlSlider');
        const gravitySlider = document.getElementById('gravitySlider');
        const dampingSlider = document.getElementById('dampingSlider');
        const lambdaSlider = document.getElementById('lambdaSlider');
        
        const swirlValue = document.getElementById('swirlValue');
        const gravityValue = document.getElementById('gravityValue');
        const dampingValue = document.getElementById('dampingValue');
        const lambdaValue = document.getElementById('lambdaValue');
        
        const uiParticleCount = document.getElementById('particleCount');
        const uiAttractorCount = document.getElementById('attractorCount');
        const psdValue = document.getElementById('psdValue');
        const sigmaValue = document.getElementById('sigmaValue');

        // Menu Toggle Elements
        const menuPanel = document.getElementById('menuPanel');
        const menuToggleButton = document.getElementById('menuToggleButton');
        const menuContent = document.getElementById('menuContent');
        const minimizeIcon = document.getElementById('minimizeIcon');
        const maximizeIcon = document.getElementById('maximizeIcon');
        let isMenuMinimized = false;
        
        // A-LMI UI Elements
        const freqBars = [
            document.getElementById('freqBar_0'),
            document.getElementById('freqBar_1'),
            document.getElementById('freqBar_2'),
            document.getElementById('freqBar_3')
        ];
        const freqCounts = [
            document.getElementById('freqCount_0'),
            document.getElementById('freqCount_1'),
            document.getElementById('freqCount_2'),
            document.getElementById('freqCount_3')
        ];
        const totalTokenCount = document.getElementById('totalTokenCount');

        // Event Listeners for Controls
        toggleMicButton.addEventListener('click', initAudio);
        
        addParticlesButton.addEventListener('click', () => {
            addParticles(10000); // Add 10k initial particles
        });
        clearParticlesButton.addEventListener('click', () => {
            particleCount = 0;
            setupParticles();
        });
        
        addAttractorButton.addEventListener('click', () => {
            const pos = new THREE.Vector3(
                (Math.random() - 0.5) * GALAXY_RADIUS,
                (Math.random() - 0.5) * (GALAXY_RADIUS * 0.2), 
                (Math.random() - 0.5) * GALAXY_RADIUS
            );
            const mass = Math.random() * 2000 + 500; 
            addAttractor(pos, mass, false);
        });
        
        clearAllButton.addEventListener('click', () => {
            particleCount = 0;
            setupParticles();
            
            attractors = [attractors[0]]; // Keep central attractor
            for (let i = attractorMeshes.children.length - 1; i >= 0; i--) {
                attractorMeshes.children[i].geometry.dispose();
                attractorMeshes.children[i].material.dispose();
                attractorMeshes.remove(attractorMeshes.children[i]);
            }
            // Clear A-LMI memory
            almiMemory = [0, 0, 0, 0];
            almiTotalTokens = 0;
            updateAlmiMemoryUI();
        });

        // Menu Toggle Listener
        menuToggleButton.addEventListener('click', () => {
            isMenuMinimized = !isMenuMinimized;
            menuContent.classList.toggle('hidden');
            minimizeIcon.classList.toggle('hidden');
            maximizeIcon.classList.toggle('hidden');
            
            if (isMenuMinimized) {
                menuPanel.classList.remove('max-w-sm');
                menuPanel.classList.add('w-auto'); // Shrink to fit header
            } else {
                menuPanel.classList.add('max-w-sm');
                menuPanel.classList.remove('w-auto');
            }
        });

        swirlSlider.addEventListener('input', (e) => {
            SWIRL_CONST = parseFloat(e.target.value);
            swirlValue.textContent = SWIRL_CONST.toFixed(2);
        });
        gravitySlider.addEventListener('input', (e) => {
            G_CONST = parseFloat(e.target.value);
            gravityValue.textContent = G_CONST.toFixed(0);
        });
        dampingSlider.addEventListener('input', (e) => {
            DAMPING = parseFloat(e.target.value);
            dampingValue.textContent = DAMPING.toFixed(3);
        });
        lambdaSlider.addEventListener('input', (e) => {
            LAMBDA_CONST = parseFloat(e.target.value);
            lambdaValue.textContent = LAMBDA_CONST.toFixed(1);
        });

        // === Helper Functions ===
        function addParticles(count, spawnConfig = null) {
            const oldParticleCount = particleCount;
            particleCount += count;
            
            // --- Efficiently resize buffers ---
            const oldPositions = positions;
            const oldVelocities = velocities;
            const oldSpeeds = speeds;
            const oldInternalStates = internalStates;
            const oldInternalAmplitudes = internalAmplitudes; 
            
            positions = new Float32Array(particleCount * 3);
            velocities = new Float32Array(particleCount * 3);
            speeds = new Float32Array(particleCount);
            internalStates = new Float32Array(particleCount);
            internalAmplitudes = new Float32Array(particleCount); 
            
            if (oldPositions) {
                positions.set(oldPositions);
                velocities.set(oldVelocities);
                speeds.set(oldSpeeds);
                internalStates.set(oldInternalStates);
                internalAmplitudes.set(oldInternalAmplitudes); 
            }
            
            for (let i = oldParticleCount; i < particleCount; i++) {
                let stateValue, amplitudeValue;
                
                if (spawnConfig) {
                    // --- Cymatic Spawn (from Mic) ---
                    stateValue = spawnConfig.internalState; // Imprinted Omega
                    amplitudeValue = spawnConfig.internalAmplitude; // Imprinted Ec
                    const theta = Math.random() * Math.PI * 2;
                    
                    positions[i * 3] = Math.cos(theta) * spawnConfig.radius;
                    positions[i * 3 + 1] = 0; // Spawn on the XZ plane
                    positions[i * 3 + 2] = Math.sin(theta) * spawnConfig.radius;
                    
                    velocities[i * 3] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 5; 
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;

                } else {
                    // --- Initial Shell Spawn (from Button) ---
                    stateValue = Math.random(); 
                    amplitudeValue = 0.5 + Math.random() * 0.5;
                    const r = Math.random() * GALAXY_RADIUS * 0.5 + 100;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1); 
                    
                    positions[i * 3] = Math.sin(phi) * Math.cos(theta) * r;
                    positions[i * 3 + 1] = Math.cos(phi) * r;
                    positions[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * r;

                    velocities[i * 3] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                }
                
                internalStates[i] = stateValue;
                internalAmplitudes[i] = amplitudeValue; 
                speeds[i] = Math.sqrt(velocities[i*3]**2 + velocities[i*3+1]**2 + velocities[i*3+2]**2);
            }
            
            // Re-setup geometry
            if (points) {
                scene.remove(points);
                points.geometry.dispose();
                points.material.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            geometry.setAttribute('internalState', new THREE.BufferAttribute(internalStates, 1));
            geometry.setAttribute('internalAmplitude', new THREE.BufferAttribute(internalAmplitudes, 1)); 

            const material = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false, 
                vertexColors: false 
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);
        });

        // === Audio Logic (VibraLight / Stochastic Resonance) ===
        function initAudio() {
            if (micOn) {
                if (audioContext) audioContext.close();
                audioContext = null;
                micOn = false;
                analyser = null;
                fftDataArray = null;
                micStatus.textContent = "Mic OFF. Using Baseline Chaos.";
                toggleMicButton.classList.remove('bg-red-600', 'hover:bg-red-500');
                toggleMicButton.classList.add('bg-cyan-500', 'hover:bg-cyan-400');
                psdNormalized = 0;
            } else {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        micOn = true;
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioContext.createAnalyser();
                        const source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        
                        analyser.fftSize = 256;
                        analyser.smoothingTimeConstant = 0.3;
                        
                        fftDataArray = new Float32Array(analyser.frequencyBinCount);

                        micStatus.textContent = "Mic ON. Your voice is CREATING the universe.";
                        toggleMicButton.classList.add('bg-red-600', 'hover:bg-red-500');
                        toggleMicButton.classList.remove('bg-cyan-500', 'hover:bg-cyan-400');
                    })
                    .catch(err => {
                        console.error('Microphone access denied:', err);
                        micStatus.textContent = "Mic access denied. Using Baseline Chaos.";
                        micOn = false;
                    });
            }
        }

        function updateVibraLight() {
            if (micOn && analyser) {
                const bufferLength = analyser.frequencyBinCount;
                analyser.getFloatFrequencyData(fftDataArray); 

                let sum = 0;
                let maxVal = -Infinity;
                let maxIndex = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const db = fftDataArray[i];
                    if (db > maxVal) {
                        maxVal = db;
                        maxIndex = i;
                    }
                    const normalized_db = (db + 100) / 100;
                    sum += normalized_db * normalized_db; 
                }
                const avgPower = sum / bufferLength;
                
                psdNormalized = Math.min(avgPower * 5, 1.0); // This is our 'Ec'
                SIGMA_FINAL = SIGMA_PSD * psdNormalized; // This is our 'lambda'
                
                psdValue.textContent = psdNormalized.toFixed(2);

                // --- Harmonic Cymatic Creation Logic ---
                const baseSpawnCount = Math.floor(psdNormalized * CYMATIC_SPAWN_COUNT);
                
                if (baseSpawnCount > 0) {
                    const dominantFrequencyNorm = maxIndex / (bufferLength - 1); // This is our 'Omega'
                    const creationRadius = CYMATIC_RADIUS_MIN + dominantFrequencyNorm * (CYMATIC_RADIUS_MAX - CYMATIC_RADIUS_MIN);
                    
                    const spawnCountPerRing = Math.max(1, Math.floor(baseSpawnCount / 4));
                    const spawnConfig = {
                        internalState: dominantFrequencyNorm, // Imprint Omega
                        internalAmplitude: psdNormalized // Imprint Ec
                    };

                    // Spawn at 4 harmonic radii
                    addParticles(spawnCountPerRing, { ...spawnConfig, radius: creationRadius });
                    addParticles(spawnCountPerRing, { ...spawnConfig, radius: creationRadius / 2 });
                    addParticles(spawnCountPerRing, { ...spawnConfig, radius: creationRadius / PHI });
                    addParticles(spawnCountPerRing, { ...spawnConfig, radius: creationRadius * PHI });
                }
                // --- End Cymatic Logic ---

            } else {
                SIGMA_FINAL = SIGMA_LAMBDA * LAMBDA_CONST;
                psdValue.textContent = "N/A";
            }
            sigmaValue.textContent = SIGMA_FINAL.toFixed(2);

            if (bloomPass) {
                 // Adjust bloom dynamically based on chaos/voice input
                bloomPass.strength = 0.8 + SIGMA_FINAL * 0.05; // Base bloom + chaos-driven intensity
                bloomPass.radius = 0.1 + SIGMA_FINAL * 0.01; // Wider glow with more chaos
            }
        }
        
        // --- A-LMI Logic ---
        function updateAlmi(dt) {
            almiScanTimer += dt;
            
            // Rotate the core
            almiCore.rotation.x += 0.001 * dt;
            almiCore.rotation.y += 0.003 * dt;
            
            // Remove old beams
            for (let i = lightTokenBeams.children.length - 1; i >= 0; i--) {
                const beam = lightTokenBeams.children[i];
                beam.material.opacity -= 0.04 * dt;
                if (beam.material.opacity <= 0) {
                    beam.geometry.dispose();
                    beam.material.dispose();
                    lightTokenBeams.remove(beam);
                }
            }
            
            // "Scientist Within" autonomous scan
            if (almiScanTimer > ALMI_SCAN_INTERVAL && particleCount > 0) {
                almiScanTimer = 0;
                
                // Find a random particle near the core to "observe"
                const scanIndex = Math.floor(Math.random() * particleCount);
                particlePos.fromArray(positions, scanIndex * 3);
                
                if (particlePos.lengthSq() < ALMI_SCAN_RADIUS * ALMI_SCAN_RADIUS) {
                    const internalState = internalStates[scanIndex];
                    
                    // -1.0 is a flag for "being processed" or invalid
                    if (internalState >= 0.0) { // Check if valid state before processing
                        processLightToken(particlePos, internalState, scanIndex);
                    }
                }
            }
        }
        
        function processLightToken(particlePos, internalState, particleIndex) {
            // 1. Visualize the "processing" beam
            const beamMat = new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                linewidth: 1, 
                transparent: true, 
                opacity: 1.0 
            });
            const beamGeom = new THREE.BufferGeometry().setFromPoints([particlePos, almiCorePos]);
            const beam = new THREE.Line(beamGeom, beamMat);
            lightTokenBeams.add(beam);
            
            // 2. Add to A-LMI Memory
            const freqBand = Math.min(3, Math.floor(internalState * 4)); // Ensure band is 0-3
            almiMemory[freqBand]++;
            almiTotalTokens++;
            
            // 3. Update the UI
            updateAlmiMemoryUI();
            
            // 4. Mark particle as "processed" by setting its state to -1.0 temporarily
            //    It will be reset by the physics loop or recycling if needed.
            //    This prevents processing the same particle multiple times quickly.
             if (particleIndex < particleCount) { // Check bounds
                 internalStates[particleIndex] = -1.0; 
                 // Reset particle immediately after processing for continuous flow
                 resetParticle(particleIndex); 
            }
        }
        
        function updateAlmiMemoryUI() {
            totalTokenCount.textContent = almiTotalTokens.toLocaleString();
            let maxTokensInBand = 1;
            for(let i=0; i<4; i++) {
                if (almiMemory[i] > maxTokensInBand) maxTokensInBand = almiMemory[i];
            }
            
            for(let i=0; i<4; i++) {
                freqCounts[i].textContent = almiMemory[i];
                const percent = maxTokensInBand > 0 ? (almiMemory[i] / maxTokensInBand) * 100 : 0;
                freqBars[i].style.width = `${percent}%`;
            }
        }
        
         function resetParticle(i) {
             if (i >= particleCount) return; // Boundary check

            // Reset particle to galactic fountain
            const y = 1 - (i / (particleCount - 1)) * 2; // Normalize i
            const radius = Math.sqrt(1 - y * y);
            const theta = GOLDEN_ANGLE * i;
            const spawnRadius = 20.0;
            
            particlePos.set(
                Math.cos(theta) * radius * spawnRadius,
                y * spawnRadius,
                Math.sin(theta) * radius * spawnRadius
            );
            
            particleVel.set(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            );
            
            // Update the main buffers directly
            positions[i*3] = particlePos.x;
            positions[i*3+1] = particlePos.y;
            positions[i*3+2] = particlePos.z;
            
            velocities[i*3] = particleVel.x;
            velocities[i*3+1] = particleVel.y;
            velocities[i*3+2] = particleVel.z;

            speeds[i] = 0.1;
            
            // Give it a new random state
            internalStates[i] = Math.random(); 
            internalAmplitudes[i] = 0.5 + Math.random() * 0.5;
        }


        // === Main Animation Loop ===
        function animate() {
            requestAnimationFrame(animate); // Loop
            
            const dt = clock.getDelta() * 10; 
            
            updateVibraLight();
            updateAlmi(dt); 
            
            if(particleCount > 0 && points) { // Check if points exists
                updatePhysics(dt); 
            }
            
            controls.update(); 
            composer.render(); // Render with post-processing

            // Visual Feedback for Mic Input
            const centralAttractor = attractors[0];
            if (centralAttractor && centralAttractor.isCentral) {
                const hue = 0.7 - (psdNormalized * 0.7);
                micColor.setHSL(hue, 1.0, 0.7);
                almiCore.material.color = micColor; // Color the A-LMI core
                almiCore.scale.setScalar(1.0 + psdNormalized * 0.5); // Pulse with voice
            }

            // Update UI Stats
            uiParticleCount.textContent = particleCount.toLocaleString();
            uiAttractorCount.textContent = attractors.length;
        }

        // === Initialization ===
        function init() {
            init3D();
            
            swirlValue.textContent = SWIRL_CONST.toFixed(2);
            gravityValue.textContent = G_CONST.toFixed(0);
            dampingValue.textContent = DAMPING.toFixed(3);
            lambdaValue.textContent = LAMBDA_CONST.toFixed(1);

            animate();
        }

        init();
    </script>
</body>
</html>

